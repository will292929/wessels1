<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Wessels Profile Frame</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; padding: 22px; background: #0b1020; color: #fff; }
    .wrap { max-width: 780px; margin: 0 auto; display: grid; gap: 14px; }
    .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12);
            border-radius: 14px; padding: 16px; }
    h1 { margin: 0 0 6px; font-size: 18px; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .small { font-size: 13px; opacity: 0.85; line-height: 1.35; }
    .error { font-size: 13px; color: #ffb4b4; white-space: pre-wrap; }
    canvas { width: 100%; max-width: 560px; border-radius: 14px;
             border: 1px solid rgba(255,255,255,0.12); background: rgba(0,0,0,0.25); }
    .btn { cursor: pointer; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08);
           color: #fff; padding: 10px 12px; border-radius: 10px; font-weight: 650; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    input[type="file"] { color: #fff; }

    /* Toggle switch */
    .switch { display: inline-flex; align-items: center; gap: 10px; user-select: none; }
    .switch span { font-size: 13px; opacity: 0.9; }
    .toggle {
      position: relative; width: 58px; height: 30px; border-radius: 999px;
      background: rgba(255,255,255,0.18); border: 1px solid rgba(255,255,255,0.22);
      cursor: pointer; flex: 0 0 auto;
    }
    .knob {
      position: absolute; top: 3px; left: 3px; width: 24px; height: 24px; border-radius: 999px;
      background: #fff; transition: transform 160ms ease;
    }
    .toggle[data-on="true"] .knob { transform: translateX(28px); }
    .pill {
      font-size: 12px; padding: 4px 8px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Profile Frame Generator</h1>

      <div class="row" style="justify-content: space-between;">
        <div class="row">
          <div>
            <div class="small">Upload a photo</div>
            <input id="file" type="file" accept="image/*" />
          </div>

          <div class="switch" id="modeSwitch" title="Toggle between circle frame and corner overlay">
            <span class="pill" id="leftLabel">Circle</span>
            <div class="toggle" id="toggle" data-on="false" role="switch" aria-checked="false">
              <div class="knob"></div>
            </div>
            <span class="pill" id="rightLabel">Corner</span>
          </div>
        </div>

        <button id="download" class="btn" disabled>Download PNG</button>
      </div>

      <div class="small" style="margin-top: 10px;">
        Put these files in the same folder as this page:
        <code>circle.png</code>, <code>corner.jpg</code>, <code>logo.png</code> (optional), <code>bg.jpg</code> (optional).
      </div>
      <div id="status" class="small" style="margin-top: 8px;"></div>
      <div id="err" class="error" style="margin-top: 8px;"></div>
    </div>

    <div class="card">
      <div class="small" style="margin-bottom: 8px;">Preview</div>
      <canvas id="c" width="1080" height="1080"></canvas>
    </div>
  </div>

<script>
(() => {
  const SIZE = 1080;

  const elFile = document.getElementById('file');
  const elDownload = document.getElementById('download');
  const elErr = document.getElementById('err');
  const elStatus = document.getElementById('status');

  const toggle = document.getElementById('toggle');
  const modeSwitch = document.getElementById('modeSwitch');

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  let userImg = null;
  let lastBlobUrl = null;

  // mode: "circle" (toggle off) or "corner" (toggle on)
  function getMode() {
    return toggle.dataset.on === "true" ? "corner" : "circle";
  }
  function setMode(mode) {
    const on = (mode === "corner");
    toggle.dataset.on = on ? "true" : "false";
    toggle.setAttribute("aria-checked", on ? "true" : "false");
    elStatus.textContent = `Mode: ${mode === "circle" ? "Circle frame (circle.png)" : "Corner overlay (corner.jpg)"}`;
  }

  function setError(msg) { elErr.textContent = msg || ""; }
  function setStatus(msg) { elStatus.textContent = msg || ""; }

  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      // If hosted on same domain, this is fine. If CDN, it helps avoid a "tainted canvas".
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = () => reject(new Error(`Failed to load "${src}". Check the filename and that you're serving via http(s), not file://`));
      img.src = src;
    });
  }

  function readFileAsImage(file) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
      img.onerror = () => { URL.revokeObjectURL(url); reject(new Error("Could not read uploaded image.")); };
      img.src = url;
    });
  }

  // center-crop cover
  function drawCover(img, dx, dy, dw, dh) {
    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;

    const scale = Math.max(dw / iw, dh / ih);
    const sw = dw / scale;
    const sh = dh / scale;

    const sx = (iw - sw) / 2;
    const sy = (ih - sh) / 2;

    ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
  }

  async function render() {
    setError("");
    elDownload.disabled = true;

    if (!userImg) {
      ctx.clearRect(0, 0, SIZE, SIZE);
      setStatus(`Mode: ${getMode() === "circle" ? "Circle frame (circle.png)" : "Corner overlay (corner.jpg)"} â€” upload a photo to preview.`);
      return;
    }

    try {
      ctx.clearRect(0, 0, SIZE, SIZE);

      // draw user photo
      drawCover(userImg, 0, 0, SIZE, SIZE);

      // overlay
      const mode = getMode();
      if (mode === "circle") {
        const circle = await loadImage("circle.png");
        ctx.drawImage(circle, 0, 0, SIZE, SIZE);
      } else {
        const corner = await loadImage("corner.jpg");
        ctx.drawImage(corner, 0, 0, SIZE, SIZE);
      }

      // optional logo stamp (comment out if you don't want it)
      try {
        const logo = await loadImage("logo.png");
        const pad = 28;
        const maxW = 240;
        const scale = Math.min(1, maxW / (logo.naturalWidth || logo.width));
        const w = (logo.naturalWidth || logo.width) * scale;
        const h = (logo.naturalHeight || logo.height) * scale;

        ctx.globalAlpha = 0.95;
        ctx.drawImage(logo, SIZE - w - pad, SIZE - h - pad, w, h);
        ctx.globalAlpha = 1;
      } catch (_) {
        // ignore if missing
      }

      canvas.toBlob((blob) => {
        if (!blob) { setError("Canvas export failed (browser blocked)."); return; }
        if (lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
        lastBlobUrl = URL.createObjectURL(blob);
        elDownload.disabled = false;
        setStatus(`Ready. Mode: ${mode}.`);
      }, "image/png");

    } catch (e) {
      setError(e.message || String(e));
    }
  }

  function download() {
    if (!lastBlobUrl) return;
    const a = document.createElement("a");
    a.href = lastBlobUrl;
    a.download = `wessels-${getMode()}-frame.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // Events
  elFile.addEventListener("change", async (ev) => {
    setError("");
    const f = ev.target.files?.[0];
    if (!f) return;
    try {
      userImg = await readFileAsImage(f);
      await render();
    } catch (e) {
      userImg = null;
      setError(e.message || String(e));
    }
  });

  modeSwitch.addEventListener("click", async () => {
    setMode(getMode() === "circle" ? "corner" : "circle");
    await render();
  });

  elDownload.addEventListener("click", download);

  // init
  setMode("circle");
  render();
})();
</script>
</body>
</html>
