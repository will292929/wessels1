<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Photo → Brand Overlay</title>
  <style>
    :root{
      --bg:#0b1020;
      --card:#121a33cc;
      --card2:#0f1630cc;
      --line:#2a355f;
      --text:#e9ecff;
      --muted:#aeb6e8;
      --accent:#7c5cff;
      --accent2:#20d3ff;
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --radius: 22px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      background:
        radial-gradient(900px 600px at 20% 10%, rgba(124,92,255,.35), transparent 60%),
        radial-gradient(800px 500px at 85% 15%, rgba(32,211,255,.25), transparent 55%),
        radial-gradient(900px 800px at 60% 95%, rgba(124,92,255,.18), transparent 65%),
        linear-gradient(180deg, #070a16, var(--bg));
      padding: 42px 18px 60px;
    }

    .wrap{ max-width: 1100px; margin: 0 auto; }
    header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:18px;
      margin-bottom: 22px;
    }

    .title h1{
      font-size: clamp(22px, 3vw, 34px);
      margin:0 0 8px 0;
      letter-spacing:.2px;
      line-height:1.15;
    }
    .title p{
      margin:0;
      color:var(--muted);
      max-width: 70ch;
      line-height:1.45;
    }

    .badge{
      display:flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border:1px solid var(--line);
      border-radius: 999px;
      background: rgba(255,255,255,.04);
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 36px rgba(0,0,0,.28);
      white-space: nowrap;
      user-select:none;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 0 0 4px rgba(124,92,255,.15);
    }
    .badge span{ color: var(--muted); font-size: 13px; }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1.2fr;
      gap: 18px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      border: 1px solid rgba(42,53,95,.9);
      background: linear-gradient(180deg, rgba(18,26,51,.82), rgba(10,14,30,.7));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .card .hd{
      padding: 16px 18px;
      border-bottom: 1px solid rgba(42,53,95,.7);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
    }
    .hd h2{
      font-size: 15px;
      margin:0;
      letter-spacing:.2px;
    }
    .hd small{ color: var(--muted); }

    .card .bd{ padding: 18px; }

    .drop{
      border: 1.5px dashed rgba(174,182,232,.45);
      border-radius: 18px;
      background: rgba(255,255,255,.03);
      padding: 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 14px;
      transition: .18s ease;
    }
    .drop.dragover{
      border-color: rgba(32,211,255,.9);
      background: rgba(32,211,255,.08);
      transform: translateY(-1px);
    }

    .drop .left{
      display:flex; flex-direction:column; gap:6px;
      min-width: 0;
    }
    .drop strong{ font-size: 14px; }
    .drop span{ font-size: 13px; color: var(--muted); line-height:1.35; }

    .btn{
      appearance:none;
      border: 1px solid rgba(124,92,255,.55);
      background: linear-gradient(135deg, rgba(124,92,255,.95), rgba(32,211,255,.75));
      color: #071022;
      font-weight: 700;
      padding: 10px 12px;
      border-radius: 14px;
      cursor:pointer;
      box-shadow: 0 14px 36px rgba(0,0,0,.35);
      transition: transform .12s ease, filter .12s ease;
      white-space:nowrap;
    }
    .btn:hover{ transform: translateY(-1px); filter: brightness(1.05); }
    .btn:active{ transform: translateY(0px); filter: brightness(0.98); }

    .btn.secondary{
      background: rgba(255,255,255,.05);
      color: var(--text);
      border: 1px solid rgba(174,182,232,.35);
      box-shadow: none;
      font-weight:600;
    }

    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 14px;
    }
    @media (max-width: 520px){
      .row{ grid-template-columns: 1fr; }
    }

    .field{
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(42,53,95,.7);
      border-radius: 16px;
      padding: 12px 12px;
    }
    .field label{
      display:flex;
      justify-content:space-between;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 8px;
    }

    select{
      width:100%;
      padding: 10px 10px;
      border-radius: 12px;
      background: rgba(8,10,20,.65);
      border: 1px solid rgba(42,53,95,.8);
      color: var(--text);
      outline:none;
    }

    .note{
      margin-top: 12px;
      color: var(--muted);
      font-size: 12.5px;
      line-height: 1.4;
    }
    .note code{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(42,53,95,.6);
      padding: 2px 6px;
      border-radius: 10px;
      color: var(--text);
    }

    .previewBox{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .canvasWrap{
      background: radial-gradient(600px 260px at 30% 20%, rgba(124,92,255,.18), transparent 60%),
                  radial-gradient(520px 220px at 75% 0%, rgba(32,211,255,.14), transparent 55%),
                  rgba(255,255,255,.02);
      border: 1px solid rgba(42,53,95,.7);
      border-radius: var(--radius);
      padding: 14px;
      overflow:auto;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }

    canvas{
      display:block;
      max-width: 100%;
      height:auto;
      border-radius: 16px;
      background: repeating-conic-gradient(from 45deg, rgba(255,255,255,.05) 0 25%, rgba(255,255,255,.02) 0 50%) 50%/18px 18px;
      border: 1px solid rgba(255,255,255,.06);
    }

    .actions{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content:flex-end;
    }

    .actions .btn[disabled]{
      opacity:.45;
      cursor:not-allowed;
      filter: grayscale(0.4);
      transform:none;
    }

    .smallprint{
      margin-top: 10px;
      font-size: 12px;
      color: rgba(174,182,232,.8);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>Photo Overlay Tool</h1>
        <p>Upload a photo and export a branded result. Runs entirely in your browser—no server, no tracking, no uploads.</p>
      </div>
      <div class="badge" title="Client-side processing only">
        <div class="dot"></div>
        <span>Client-side • PNG export</span>
      </div>
    </header>

    <div class="grid">
      <!-- Controls -->
      <section class="card">
        <div class="hd">
          <h2>Inputs & Rules</h2>
          <small>Brand-safe defaults</small>
        </div>
        <div class="bd">
          <div id="drop" class="drop">
            <div class="left">
              <strong>Drop a photo here</strong>
              <span>Or choose a file. JPG/PNG/WebP supported.</span>
            </div>
            <button id="chooseBtn" class="btn" type="button">Choose Photo</button>
            <input id="photoInput" type="file" accept="image/*" hidden />
          </div>

          <div class="row">
            <div class="field">
              <label>
                <span>Overlay mode</span>
                <span id="modeHint">Logo centered, fixed size</span>
              </label>
              <select id="mode">
                <option value="bottom-center" selected>Bottom Center Logo</option>
                <option value="top-center">Top Center Logo</option>
                <option value="profile-circle">Profile Circle (Square PNG)</option>
              </select>
            </div>

            <div class="field">
              <label>
                <span>Export filename</span>
                <span>(auto)</span>
              </label>
              <select id="namePreset">
                <option value="photo-with-logo">photo-with-logo</option>
                <option value="branded-photo">branded-photo</option>
                <option value="profile-circle">profile-circle</option>
              </select>
            </div>
          </div>

          <div class="note">
            <div><strong>Asset paths (required):</strong></div>
            <div>Main logo: <code>assets/logo.png</code> (used for top/bottom)</div>
            <div>Circle overlay: <code>assets/circle.png</code> (used for profile-circle)</div>
            <div style="margin-top:10px;">
              <strong>Hard rules enforced:</strong><br/>
              • Logo width = <strong>50%</strong> of photo width (top/bottom modes)<br/>
              • Circle mode exports a <strong>square</strong> PNG with a <strong>circular</strong> photo mask, optimized for profile pics
            </div>
          </div>

          <div class="actions" style="margin-top:16px;">
            <button id="renderBtn" class="btn secondary" type="button" disabled>Render</button>
            <button id="downloadBtn" class="btn" type="button" disabled>Download PNG</button>
          </div>

          <div class="smallprint">
            Tip: Use transparent PNGs for <code>logo.png</code> and <code>circle.png</code> for best results.
          </div>
        </div>
      </section>

      <!-- Preview -->
      <section class="card">
        <div class="hd">
          <h2>Preview</h2>
          <small id="sizeReadout">—</small>
        </div>
        <div class="bd">
          <div class="previewBox">
            <div class="canvasWrap">
              <canvas id="canvas"></canvas>
            </div>
            <div class="smallprint" id="status">
              Upload a photo to begin.
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    // ====== Config (repo assets) ======
    const ASSET_LOGO = 'assets/logo.png';
    const ASSET_CIRCLE = 'assets/circle.png';

    // ====== Elements ======
    const drop = document.getElementById('drop');
    const chooseBtn = document.getElementById('chooseBtn');
    const photoInput = document.getElementById('photoInput');
    const mode = document.getElementById('mode');
    const modeHint = document.getElementById('modeHint');
    const namePreset = document.getElementById('namePreset');
    const renderBtn = document.getElementById('renderBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    const statusEl = document.getElementById('status');
    const sizeReadout = document.getElementById('sizeReadout');

    // ====== State ======
    let photoImg = null;
    let cachedLogo = null;
    let cachedCircle = null;

    // ====== Helpers ======
    function setStatus(text){ statusEl.textContent = text; }
    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

    function readImageFile(file){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Failed to load image.'));
        const reader = new FileReader();
        reader.onload = (e) => { img.src = e.target.result; };
        reader.onerror = () => reject(new Error('File read error.'));
        reader.readAsDataURL(file);
      });
    }

    function loadImageFromUrl(url){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Missing asset: ' + url));
        img.src = url;
      });
    }

    function setCanvasSizePx(width, height){
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
    }

    function drawCover(img, dx, dy, dw, dh){
      // draw img to fully cover destination rect, cropping as needed
      const sw = img.naturalWidth;
      const sh = img.naturalHeight;
      const sRatio = sw / sh;
      const dRatio = dw / dh;

      let sx, sy, sW, sH;
      if (sRatio > dRatio) {
        // source wider → crop sides
        sH = sh;
        sW = Math.round(sh * dRatio);
        sx = Math.round((sw - sW) / 2);
        sy = 0;
      } else {
        // source taller → crop top/bottom
        sW = sw;
        sH = Math.round(sw / dRatio);
        sx = 0;
        sy = Math.round((sh - sH) / 2);
      }
      ctx.drawImage(img, sx, sy, sW, sH, dx, dy, dw, dh);
    }

    async function ensureAssets(){
      if (!cachedLogo) cachedLogo = await loadImageFromUrl(ASSET_LOGO);
      if (!cachedCircle) cachedCircle = await loadImageFromUrl(ASSET_CIRCLE);
    }

    function updateHint(){
      const v = mode.value;
      if (v === 'profile-circle') modeHint.textContent = 'Square PNG for profile use';
      else modeHint.textContent = 'Logo centered, fixed at 50% width';
    }

    // ====== Rendering rules ======
    async function render(){
      if (!photoImg) return;

      setStatus('Rendering…');
      renderBtn.disabled = true;
      downloadBtn.disabled = true;

      try{
        // Load needed asset(s)
        if (mode.value === 'profile-circle') {
          // circle mode uses circle.png
          if (!cachedCircle) cachedCircle = await loadImageFromUrl(ASSET_CIRCLE);
        } else {
          // top/bottom uses logo.png
          if (!cachedLogo) cachedLogo = await loadImageFromUrl(ASSET_LOGO);
        }

        const m = mode.value;

        if (m === 'profile-circle'){
          // PROFILE CIRCLE:
          // - output is square (min dimension)
          // - photo is cover-cropped to square
          // - masked to a perfect circle (transparent outside)
          // - circle.png overlaid to full canvas (frame/badge)
          const out = Math.min(photoImg.naturalWidth, photoImg.naturalHeight);
          setCanvasSizePx(out, out);

          ctx.clearRect(0, 0, out, out);

          // Draw photo as a square (cover)
          // We'll draw to a temp layer via clipping.
          const cx = out / 2;
          const cy = out / 2;
          const radius = out / 2; // full circle

          // Clip to circle
          ctx.save();
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.closePath();
          ctx.clip();

          drawCover(photoImg, 0, 0, out, out);
          ctx.restore();

          // Overlay circle asset as cover to full canvas
          // This asset should be a transparent ring/frame/badge.
          drawCover(cachedCircle, 0, 0, out, out);

          sizeReadout.textContent = `${out} × ${out} (square)`;
          setStatus('Ready. This export is a square PNG with a circular mask—ideal for profile pics.');

        } else {
          // TOP/BOTTOM CENTER LOGO:
          // - output keeps original photo size
          // - logo width fixed to 50% of photo width
          // - centered horizontally; vertically at top or bottom with margin
          const w = photoImg.naturalWidth;
          const h = photoImg.naturalHeight;
          setCanvasSizePx(w, h);

          ctx.clearRect(0, 0, w, h);
          ctx.drawImage(photoImg, 0, 0, w, h);

          const logoW = Math.round(w * 0.50); // HARD RULE: 50% of photo width
          const logoAspect = cachedLogo.naturalWidth / cachedLogo.naturalHeight;
          const logoH = Math.round(logoW / logoAspect);

          const margin = Math.round(Math.min(w, h) * 0.035);
          const x = Math.round((w - logoW) / 2);
          const y = (m === 'top-center')
            ? margin
            : Math.round(h - logoH - margin);

          // Draw logo
          ctx.drawImage(cachedLogo, x, y, logoW, logoH);

          sizeReadout.textContent = `${w} × ${h}`;
          setStatus('Ready. Logo is locked to 50% width and centered.');
        }

        downloadBtn.disabled = false;
      } catch(err){
        console.error(err);
        setStatus(err.message || 'Render failed.');
      } finally {
        renderBtn.disabled = false;
      }
    }

    function download(){
      const base = namePreset.value || 'export';
      const filename = `${base}.png`;
      const url = canvas.toDataURL('image/png');

      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
    }

    // ====== UI events ======
    chooseBtn.addEventListener('click', () => photoInput.click());

    photoInput.addEventListener('change', async () => {
      const file = photoInput.files?.[0];
      if (!file) return;

      if (!file.type.startsWith('image/')){
        setStatus('Please choose an image file.');
        return;
      }
      // Reasonable client-side guardrail (you can raise/lower this)
      if (file.size > 35 * 1024 * 1024){
        setStatus('That file is large. Consider using an image under ~35MB for best performance.');
      }

      try{
        setStatus('Loading photo…');
        photoImg = await readImageFile(file);
        renderBtn.disabled = false;
        await render();
      } catch(err){
        console.error(err);
        setStatus(err.message || 'Failed to load photo.');
      }
    });

    mode.addEventListener('change', async () => {
      updateHint();
      if (!photoImg) return;
      await render();
    });

    renderBtn.addEventListener('click', render);
    downloadBtn.addEventListener('click', download);

    // Drag & drop
    ['dragenter','dragover'].forEach(evt =>
      drop.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        drop.classList.add('dragover');
      })
    );
    ['dragleave','drop'].forEach(evt =>
      drop.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        drop.classList.remove('dragover');
      })
    );
    drop.addEventListener('drop', async (e) => {
      const file = e.dataTransfer.files?.[0];
      if (!file) return;
      // Put file into input for consistency
      const dt = new DataTransfer();
      dt.items.add(file);
      photoInput.files = dt.files;
      photoInput.dispatchEvent(new Event('change'));
    });

    // Warm-load assets (non-fatal)
    (async () => {
      updateHint();
      try{
        // Don’t force both; try both so missing assets are discovered early.
        cachedLogo = await loadImageFromUrl(ASSET_LOGO);
      } catch(e){ /* ignore until needed */ }
      try{
        cachedCircle = await loadImageFromUrl(ASSET_CIRCLE);
      } catch(e){ /* ignore until needed */ }
    })();
  </script>
</body>
</html>
